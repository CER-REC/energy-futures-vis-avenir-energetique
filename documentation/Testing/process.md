# Testing Process

## Intention

The goal of testing is to ensure that there are no bugs in the reasonable uses
of the visualization. As more functionality is developed and whenever bugs are
fixed, our test coverage will improve, and the number of edge-cases will
decrease. A useful tool for determining what hasn't been tested is the coverage
report, however we should strive for valuable tests over coverage percentage. A
covered line may not be the focus of a specific test, and we should visually
compare the code to the tests and reason whether a line is sufficiently covered.

## Testing Libraries

In terms of testing, the 'Testing Pyramid' is a general example of how different
types of testing interact together. The difference for React is that it is
opinionated in how data and logic are linked. Meaning that components being
composed of other components make it hard to do unit test in isolation.

To not abstract testing too much, it's easy to view tests in 3 categories.
From smallest largest they are: Unit Tests, Integration (or Service) Tests,
and UI tests.
[Test Pyramid in depth](https://martinfowler.com/articles/practical-test-pyramid.html)

When we test our React components, we aren't looking to ensure that it generates
exact DOM output, since that would create too tight of a coupling between our
tests and our components. Instead, we aim to test functionality, such as `if I
pass a "disabled" property to the component, does clicking it still trigger a
callback?`

### What we are using:

#### [Jest](https://jestjs.io/)

Jest is our mutli-tool for testing, and provides the groundwork for clean, fast,
and in-depth tests. We use it in combination with Enzyme and Storybook to ensure
that our components are behaving as expected, and that we aren't introducing
unexpected changes to the design.

##### Unit Tests

We use unit tests to ensure that our logic is behaving as expected. These are
implemented with four main functions that allow us to explain what is being
tested and confirm that actions provide the expected result.

* `describe`: An indicator of what unit is being tested (component, utility, etc)
* `test`: An indicator of what logic is being tested (adds classname, calculates
  formula, etc)
* `expect`: An assertation that something (variable, DOM, etc) matches our
  expectations
* `jest.fn`: Fixtures and mocks that allow us to confirm that components are
  interacting with each other properly.

##### Snapshots

We have integrated Jest and Storybook in order to take a snapshot of the
generated HTML for each story in our documentation. This provides us with early
detection of design-breaking changes, and helps to enforce a consistent appearance.
These tests are generated by calling the 'getSnapshotBeforeUpdate()' life-cycle
method and tracking the changes that are made to the DOM. This can act as a UI
test, as opposed to the unit tests that we write for logic. In the future, we
may also integrate visual regression tests through Jest snapshots to detect
changes that affect fonts and colours, but not structure.

##### Test Coverage

We don't use test coverage as a metric for tracking the quality of our codebase,
but as a way of detecting designs that are missing stories or pieces of logic
that may require additional testing. By running individual tests and comparing
the resulting coverage reports, we may also find areas that can benefit from
further optimization and testing.

#### [Enzyme](https://airbnb.io/enzyme/)
In normal object-oriented testing, we are
able to compare expected inputs and outputs of our logic, since it can be broken
down into standalone functions. Because React connects our logic with the DOM,
it requires a slightly different approach, and we (partially) render our components
and test their output.

We are using enzyme to help with then render portion of the unit under test.
Part of the problem is that we want to test an isolated component that is not
linked to other dependencies. Therefore Enzyme allows us to use 'shallow' to
render a single component without the children it needs to support (a lot of
this has to with how the react life cycle methods work in the initialization
stage and that children are needed to initialize before render and other
life-cycle methods can be run by default). There are other methods that we can
use to render components with their children when we want to start doing integration
tests. Enzymes Mount and Render function allow us to do that.

#### [Storybook](https://storybook.js.org/)
If all the unit, integration and
snapshot tests pass we still aren't viewing the actual rendered output. The last
two types of tests complete the cycle. First is storybook which is a way for
testers and developers to see the components rendered out in isolation hydrated
with props, it also gives us the ability to see the components at different
states using specific props.

Furthermore, we have snapshots which can be done by headless browsers.
This is our last bit of functionality that we can use to do pixel matching to
test output on various screen sizes and resolutions. This part is more important,
as designers have created specific ratios based on design principles. By
checking that we are following those requirements, we can now ensure that the
money spent on design was implemented across multiple view-ports.

### End to End Testing
We have chosen not to implement End to End tests at this point, since it provides
significantly less value for visualizations that do not rely heavily on other
services.  Google's Testing Blog explains
[why E2E testing shouldn't necessarily be trusted](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html).
